---
title: "County analysis of OH"
author: "Tyson Wepprich"
date: "Tuesday, August 05, 2014"
output: html_document
---
Goals:
County-level metrics of land cover.
From NLCD rasters on land cover, LC change, and crop data.
Chracterize counties by land use, change, and crop patch diversity.

Update 10/30/14: Made new raw GIS layers of clipped landcover products. Will now use these.
Also, need to include counties in other states bordering OH for buffers that go over state line.



In this chunk, I find landcover by county for 2001, 2006, and 2011. Also the 1992-2001 landcover change by county. These will be used for pesticide use rejiggering from county average to survey buffers. 


```{r}
library(rgdal)
library(raster)
library(plotKML)
library(parallel)

setwd("C:/Users/Tyson/Desktop/Clipped/Final clipped")

#######################
#2006 Landcover
#################
test.file <- "lc2006.tif"
r <- raster(test.file)
# hasValues(r)
# inMemory(r)
# plot(r)

#set CRS as Equal Albers Area projection
proj4string(r) <- CRS("+init=epsg:5070")

#bring in county shapefile and reproject to match rasters
co.shp <- "oh_counties_plus"
OHco <- readOGR(dsn = getwd(), layer = co.shp)
OHco_p <- reproject(OHco, proj4string(r))

#Function to extract land use pixels from raster by county GEOID
### Make function and try it out before parallelizing
    ### ########################################################
    RasterToCounty <- function(GEOID){
      co_sub <- OHco_p[OHco_p$GEOID == GEOID, ]
      co_lc <- extract(r, co_sub)
      counts <- lapply(co_lc, table)
      #pct <- lapply(counts, FUN=function(x){x / sum(x)})
      return(list(GEOID, counts))
    }

    #test <- lapply(unique(OHco_p$GEOID)[1:2], RasterToCounty)

#Runtime 1.75 hours
system.time({
    ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(4)

    clusterExport(cl, c("OHco_p", "RasterToCounty", "r"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    results.par <- parLapply(cl, unique(OHco_p$GEOID), RasterToCounty)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})

save(results.par, file = "lc_OH2006.RData") 


######################
#2001 landcover
######################
test.file <- "lc2001.tif"
r <- raster(test.file)
# hasValues(r)
# inMemory(r)
# plot(r)

#set CRS as Equal Albers Area projection
proj4string(r) <- CRS("+init=epsg:5070")

#Runtime 1.75 hours
system.time({
    ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(4)

    clusterExport(cl, c("OHco_p", "RasterToCounty", "r"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    results.par <- parLapply(cl, unique(OHco_p$GEOID), RasterToCounty)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})

save(results.par, file = "lc_OH2001.RData") 

##################
#2011 landcover
######################

test.file <- "lc2011.tif"
r <- raster(test.file)
# hasValues(r)
# inMemory(r)
# plot(r)

#set CRS as Equal Albers Area projection
proj4string(r) <- CRS("+init=epsg:5070")

#Runtime 1.75 hours
system.time({
    ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(4)

    clusterExport(cl, c("OHco_p", "RasterToCounty", "r"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    results.par <- parLapply(cl, unique(OHco_p$GEOID), RasterToCounty)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})

save(results.par, file = "lc_OH2011.RData") 



##################
#Change from 1992 to 2001 landcover
######################

test.file <- "lc_chg_9201.tif"
r <- raster(test.file)
# hasValues(r)
# inMemory(r)
# plot(r)

#set CRS as Equal Albers Area projection
proj4string(r) <- CRS("+init=epsg:5070")

#Runtime 1.75 hours
system.time({
    ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(4)

    clusterExport(cl, c("OHco_p", "RasterToCounty", "r"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    results.par <- parLapply(cl, unique(OHco_p$GEOID), RasterToCounty)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})

save(results.par, file = "lc_chg_9201.RData") 


```


For each county x compound x year, I want to estimate amount of pesticide used scaled by cropland landcover.
Need to bring together landcover (county-scale) estimates for 4 landcover products first. Possibly use linear trend from 1992-2011.


```{r rescale pesticides}
library(rgdal)
library(raster)
library(parallel)
library(plyr)
library(dplyr)
library(ggplot2)

setwd("C:/Users/Tyson/Desktop")
pests <- read.csv("Pesticides/OHpesticides.csv", header = TRUE)

load(file = "Clipped/Final clipped/lc_chg_9201.RData")
lc_chg90s <- results.par
load(file = "Clipped/Final clipped/lc_OH2011.RData")
lc_2011 <- results.par
load(file = "Clipped/Final clipped/lc_OH2006.RData")
lc_2006 <- results.par
load(file = "Clipped/Final clipped/lc_OH2001.RData")
lc_2001 <- results.par
rm(results.par)

#One issue is that landcover classification is different in 1992. The change product allows comparison
#BUT, only more general Anderson Level I classification (7 classes) will be used
ALIclass <- read.csv("nlcd_class9201.csv", header = TRUE)


CountyPixels <- function(lc){
  results <- lc
  lc_long <- data.frame()
  for (i in 1:length(results)){
    GEOID <- unlist(results[[i]][1])
    Pixels <- as.numeric(unlist(results[[i]][2]))
    Class <- names(unlist(results[[i]][2]))
    temp <- data.frame(GEOID, Pixels, Class)
    lc_long <- rbind(lc_long, temp)
    }
  return(lc_long)
}

pix_2001 <- CountyPixels(lc_2001)
pix_2006 <- CountyPixels(lc_2006)
pix_2011 <- CountyPixels(lc_2011)
pix_chg90s <- CountyPixels(lc_chg90s)

#one issue is that the number of pixels per county is slightly off between 1992 and 2001, unknown why.
#In same projection, but maybe paths of satellites different. Generally <100 pixels = 0.09 km2

#translation table for 2001, 2006, 2011 ALII codes back to ALI codes
landclass <- data.frame(Value = c(0, 11, 21, 22, 23, 24, 31, 41, 42, 43, 52, 71, 81, 82, 90, 95), Class = c("NoData", "Water", "Urban", "Urban", "Urban", "Urban", "Barren", "Forest", "Forest", "Forest", "Grass", "Grass", "Agri", "Agri", "Wet", "Wet"), ALIcode = c(0, 1, 2, 2, 2, 2, 3, 4, 4, 4, 5, 5, 6, 6, 7, 7))


#these give Anderson Level I classes (total pixels) for each county
lc_county_2001 <- pix_2001 %>% 
  group_by(GEOID) %>% 
  mutate(reclass = mapvalues(Class, from = landclass$Value, to = landclass$ALIcode)) %>% 
  group_by(GEOID, reclass) %>% 
  summarise(total = sum(Pixels)) %>% data.frame()

lc_county_2006 <- pix_2006 %>% 
  group_by(GEOID) %>% 
  mutate(reclass = mapvalues(Class, from = landclass$Value, to = landclass$ALIcode)) %>% 
  group_by(GEOID, reclass) %>% 
  summarise(total = sum(Pixels)) %>% data.frame()

lc_county_2011 <- pix_2011 %>% 
  group_by(GEOID) %>% 
  mutate(reclass = mapvalues(Class, from = landclass$Value, to = landclass$ALIcode)) %>% 
  group_by(GEOID, reclass) %>% 
  summarise(total = sum(Pixels)) %>% data.frame()

#make function to define 1992 and 2001 land cover from the NLCD change product
#it will be approximate
pix_chg90s$reclass92 <- sapply(as.character(pix_chg90s$Class), substring, 1, 1)
pix_chg90s$reclass01 <- sapply(formatC(as.character(pix_chg90s$Class), width = 2, format = "d", flag = "0"), substring, 2, 2)

lc_county_1992_est <- pix_chg90s %>%
  group_by(GEOID, reclass92) %>%
  summarise(total = sum(Pixels)) %>% data.frame()

lc_county_2001_est <- pix_chg90s %>%
  group_by(GEOID, reclass01) %>%
  summarise(total = sum(Pixels)) %>% data.frame()

#compare 2001 estimates for fun
#estimates are pretty darn close, from now on, just will use 1992 land cover from chg layer
names(lc_county_2001_est)[2] <- "reclass"
lc_compare <- merge(lc_county_2001, lc_county_2001_est, by = c("GEOID", "reclass"))

a <- ggplot(lc_compare, aes(x = total.x, y = total.y)) + geom_point()
a + facet_wrap(~reclass)

#bring all estimates together in one data frame
lc_county_2001$year <- 2001
lc_county_2006$year <- 2006
lc_county_2011$year <- 2011
lc_county_1992_est$year <- 1992
names(lc_county_1992_est)[2] <- "reclass"

lc_all <- rbind(lc_county_1992_est, lc_county_2001, lc_county_2006, lc_county_2011)
write.csv(lc_all, file = "landcover_all.csv", row.names = FALSE)

b <- ggplot(lc_all[lc_all$GEOID == 26115,], aes(x = year, y = total, group = GEOID)) + geom_point()
b + facet_wrap(~reclass) + geom_smooth(method = "lm")





```

Chunks below are mostly first attempts/graveyard of failures.

Now summarize land cover by county, control by land area, since many counties have much Lake Erie area. Need to 
```{r}
library(plyr)
library(dplyr)


load(file = "lc_OH.RData")

landclass <- data.frame(Value = c(11, 12, 21, 22, 23, 24, 31, 41, 42, 43, 51, 52, 71, 72, 73, 74, 81, 82, 90, 95), Class = c("Open water", "Ice.snow", "Developed.open", "Developed.low", "Developed.med", "Developed.high", "Barren", "Forest.dec", "Forest.evg", "Forest.mix", "Scrub.dwarf", "Shrub", "Herb.grass", "Herb.sedge", "Herb.lichens", "Herb.moss", "Cult.hay", "Cult.crops", "Wetlands.wood", "Wetlands.herb"))

lc_long <- data.frame()
for (i in 1:length(results)){
  GEOID <- unique(OHco_p$GEOID)[i]
  Prop.area <- unlist(results[[i]])
  Value <- c(names(unlist(results[[i]])))
  temp <- data.frame(GEOID,Prop.area,Value)
  lc_long <- rbind(lc_long, temp)
}

co_desc <- OHco_p@data
co_desc <- co_desc[, c("GEOID", "NAME", "ALAND", "AWATER", "INTPTLAT", "INTPTLON")]

county_lc <- merge(lc_long, co_desc)

a <- county_lc %>% group_by(GEOID, Value) %>% mutate(prop.land.area = Prop.area * (ALAND + AWATER) / ALAND) %>% data.frame()

#Need to remove water and No data
plot(a$Prop.area, a$prop.land.area)

#translation table to reclass land cover values
#translation table to reclass land cover values
tt <- cbind(c("0", landclass$Value), c("missing", "water", "ice", "urb", "urb", "urb", "urb", "barren", "forest", "forest", "forest", rep("grass_shrub", 6), "agr", "agr", "wetlands", "wetlands"))

a$reclass = as.factor(tt[ match(a$Value, tt[, 1]), 2] )

b <- ddply(a, .(GEOID, reclass), mutate,
           Class.prop = sum(prop.land.area))

county_lc <- b[b$reclass %in% c("agr", "urb", "forest", "grass_shrub", "wetlands"), c("GEOID", "NAME", "ALAND", "INTPTLAT", "INTPTLON", "reclass", "Class.prop")]

county_lc <- county_lc[-(which(duplicated(county_lc))), ]
write.csv(county_lc, file = "county_lc2006.csv", row.names = FALSE)

```

Repeat for other years of Land Cover measures 2011

```{r}


library(rgdal)
library(raster)
library(plotKML)
setwd("C:/Users/Tyson/Desktop/OSS_GIS")


test.file <- "CDL_soil/land_use_land_cover/nlcd_oh_utm17.tif"
r <- raster(test.file)
hasValues(r)
inMemory(r)
plot(r)

# #slow reprojection, install FW tools
# proj4string(r) <- CRS("+init=epsg:5070")
# r_p <- reproject(r)

co.shp <- "county_OH"
OHco <- readOGR(dsn = getwd(), layer = co.shp)
OHco_p <- spTransform(OHco, CRS(proj4string(r)))

results <- list()
for (i in 76:length(unique(OHco_p$GEOID))){
  co_sub <- OHco_p[OHco_p$GEOID == unique(OHco_p$GEOID)[i], ]
  co_lc <- extract(r, co_sub)
  counts <- lapply(co_lc, table)
  pct <- lapply(counts, FUN=function(x){x / sum(x)})
  results[[i]] <- pct
  }
save(results, file = "lc_OH2011.RData") 

load(file = "lc_OH2011.RData")

library(plyr)
library(dplyr)

landclass <- data.frame(Value = c(11, 12, 21, 22, 23, 24, 31, 41, 42, 43, 51, 52, 71, 72, 73, 74, 81, 82, 90, 95), Class = c("Open water", "Ice.snow", "Developed.open", "Developed.low", "Developed.med", "Developed.high", "Barren", "Forest.dec", "Forest.evg", "Forest.mix", "Scrub.dwarf", "Shrub", "Herb.grass", "Herb.sedge", "Herb.lichens", "Herb.moss", "Cult.hay", "Cult.crops", "Wetlands.wood", "Wetlands.herb"))

lc_long <- data.frame()
for (i in 1:length(results)){
  GEOID <- unique(OHco_p$GEOID)[i]
  Prop.area <- unlist(results[[i]])
  Value <- c(names(unlist(results[[i]])))
  temp <- data.frame(GEOID,Prop.area,Value)
  lc_long <- rbind(lc_long, temp)
}

co_desc <- OHco_p@data
co_desc <- co_desc[, c("GEOID", "NAME", "ALAND", "AWATER", "INTPTLAT", "INTPTLON")]

county_lc <- merge(lc_long, co_desc)

a <- county_lc %>% group_by(GEOID, Value) %>% mutate(prop.land.area = Prop.area * (ALAND + AWATER) / ALAND) %>% data.frame()

#Need to remove water and No data
plot(a$Prop.area, a$prop.land.area)

#translation table to reclass land cover values
tt <- cbind(c("0", landclass$Value), c("missing", "water", "ice", "urb", "urb", "urb", "urb", "barren", "forest", "forest", "forest", rep("grass_shrub", 6), "agr", "agr", "wetlands", "wetlands"))

a$reclass = as.factor(tt[ match(a$Value, tt[, 1]), 2] )

b <- ddply(a, .(GEOID, reclass), mutate,
           Class.prop = sum(prop.land.area))

county_lc <- b[b$reclass %in% c("agr", "urb", "forest", "grass_shrub", "wetlands"), c("GEOID", "NAME", "ALAND", "INTPTLAT", "INTPTLON", "reclass", "Class.prop")]

county_lc <- county_lc[-(which(duplicated(county_lc))), ]
write.csv(county_lc, file = "county_lc2011.csv", row.names = FALSE)



```

Let's try raster processing in parallel for fun for 2001 NLCD data. Also need to merge raster files.


```{r}

library(rgdal)
library(raster)
library(plotKML)
library(plyr)
library(dplyr)

setwd("C:/Users/Tyson/Desktop/OSS_GIS/NLCD 2001")

files <- character()
for (i in 1:4){
  files[i] <- paste(dir()[i], "/", dir()[i], ".tif", sep = "")
}

r1 <- raster(files[1])
r2 <- raster(files[2])
r3 <- raster(files[3])
r4 <- raster(files[4])

#merge or mosaic, overlapping but merge did fine I think
x <- list(r1, r2, r3, r4)
x$filename <- 'OH_NLCD2001.tif'
x$overwrite <- TRUE
m <- do.call(merge, x)

# #slow reprojection, install FW tools
# proj4string(r) <- CRS("+init=epsg:5070")
# r_p <- reproject(r)

co.shp <- "county_OH"
OHco <- readOGR(dsn = getwd(), layer = co.shp)
OHco_p <- spTransform(OHco, CRS(proj4string(m)))

library(parallel)
system.time({

    ### Make function and try it out before parallelizing
    ### ########################################################
#     RasterToCounty <- function(GEOID){
#       co_sub <- OHco_p[OHco_p$GEOID == GEOID, ]
#       co_lc <- extract(m, co_sub)
#       counts <- lapply(co_lc, table)
#       pct <- lapply(counts, FUN=function(x){x / sum(x)})
#       return(list(GEOID, pct))
#     }
# 
#     test <- lapply(unique(OHco_p$GEOID)[1:2], RasterToCounty)
    
    ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(3)

    clusterExport(cl, c("OHco_p", "RasterToCounty", "m"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    Results.par <- parLapply(cl, unique(OHco_p$GEOID), RasterToCounty)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})


save(Results.par, file = "lc_OH2001.RData") 

load(file = "lc_OH2001.RData")

landclass <- data.frame(Value = c(11, 12, 21, 22, 23, 24, 31, 41, 42, 43, 51, 52, 71, 72, 73, 74, 81, 82, 90, 95), Class = c("Open water", "Ice.snow", "Developed.open", "Developed.low", "Developed.med", "Developed.high", "Barren", "Forest.dec", "Forest.evg", "Forest.mix", "Scrub.dwarf", "Shrub", "Herb.grass", "Herb.sedge", "Herb.lichens", "Herb.moss", "Cult.hay", "Cult.crops", "Wetlands.wood", "Wetlands.herb"))

results <- Results.par

lc_long <- data.frame()
for (i in 1:length(results)){
  GEOID <- unique(OHco_p$GEOID)[i]
  Prop.area <- unlist(results[[i]])
  Value <- c(names(unlist(results[[i]])))
  temp <- data.frame(GEOID,Prop.area,Value)
  lc_long <- rbind(lc_long, temp)
}

co_desc <- OHco_p@data
co_desc <- co_desc[, c("GEOID", "NAME", "ALAND", "AWATER", "INTPTLAT", "INTPTLON")]

county_lc <- merge(lc_long, co_desc)

a <- county_lc %>% group_by(GEOID, Value) %>% mutate(prop.land.area = Prop.area * (ALAND + AWATER) / ALAND) %>% data.frame()

#Need to remove water and No data
plot(a$Prop.area, a$prop.land.area)

#translation table to reclass land cover values
tt <- cbind(c("0", landclass$Value), c("missing", "water", "ice", "urb", "urb", "urb", "urb", "barren", "forest", "forest", "forest", rep("grass_shrub", 6), "agr", "agr", "wetlands", "wetlands"))

a$reclass = as.factor(tt[ match(a$Value, tt[, 1]), 2] )

b <- ddply(a, .(GEOID, reclass), mutate,
           Class.prop = sum(prop.land.area))

county_lc <- b[b$reclass %in% c("agr", "urb", "forest", "grass_shrub", "wetlands"), c("GEOID", "NAME", "ALAND", "INTPTLAT", "INTPTLON", "reclass", "Class.prop")]

county_lc <- county_lc[-(which(duplicated(county_lc))), ]
write.csv(county_lc, file = "county_lc2001.csv", row.names = FALSE)
```

Bring 2001, 2006, 2011 land cover county summaries together. Do PCA on each separately: not much difference.
Aggregate all predictors for model.

```{r}
library(reshape2)
library(plyr)
library(dplyr)
library(ggplot2)
setwd("C:/Users/Tyson/Desktop/OSS_GIS")

lc01 <- read.csv("county_lc2001.csv", header = TRUE)
lc01$year <- 2001
lc06 <- read.csv("county_lc2006.csv", header = TRUE)
lc06$year <- 2006
lc11 <- read.csv("county_lc2011.csv", header = TRUE)
lc11$year <- 2011

pca.data <- lc11[, c("GEOID", "reclass", "Class.prop")]
test <- dcast(pca.data, GEOID ~ reclass, value.var = "Class.prop", fill = 0)

#test <- chem.data %>% group_by(GEOID) %>% summarise(COMPOUND, County.density, fill = 0) %>% group_by(GEOID)

#try different states
pca.data <- scale(test[, -1])
# pca.data <- pca.data[ , apply(pca.data, 2, function(x) !any(is.na(x)))]
test.pca <- princomp(pca.data)
summary(test.pca)
biplot(test.pca)
loadings(test.pca)

#aggregate years
LC_trend <- rbind(lc01, lc06, lc11)

test <- LC_trend %>% group_by(GEOID, reclass) %>% summarise(Change10yr = Class.prop[year == 2011] - Class.prop[year == 2001])
#see changes between land classes in magnitude of changes
tapply(test$Change10yr, test$reclass, max)


m <- ggplot(test[-which(test$reclass == "wetlands"),], aes(x = Change10yr))
m + stat_bin()
m + stat_bin(breaks=seq(-.042,.042, by=0.001)) + facet_grid(reclass ~ .) + theme_bw() + theme(axis.title.x = element_text(size = 30), axis.title.y = element_text(size = 30), strip.text.y = element_text(size = 25), axis.text.x = element_text(size = 25)) + geom_vline(aes(x=0), color = "red", lty = "dashed", size = 2)
  theme(strip.text.y = element_text(size=12, face="bold")


write.csv(LC_trend, "OH_LC_time.csv", row.names = FALSE)

```

Take Silvia's biodiversity data and geocode to match survey coordinates to OH counties.

```{r}

library(rgdal)
library(raster)
library(plotKML)
library(plyr)
library(dplyr)
setwd("C:/Users/Tyson/REPO/NCEAS-RENCI_2014")
co.shp <- "county_OH"
OHco <- readOGR(dsn = getwd(), layer = co.shp)


###BUTTERFLIES
bfly_div <- read.csv("butterfly_diversity.csv", header = TRUE)

plot(OHco)
points(bfly_div$Longitude, bfly_div$Latitude)

BflyGeo <- SpatialPointsDataFrame(cbind(bfly_div$Longitude, bfly_div$Latitude), data = bfly_div, proj4string = CRS(proj4string(OHco)))

o <- over(BflyGeo, OHco, returnList = FALSE)
BflyGeo@data = cbind(BflyGeo@data, o$GEOID, o$NAME)

write.csv(BflyGeo@data, file = "Bflydata.by.county.csv", row.names = FALSE)


###BIRDS
BBS_div <- read.csv("BBS_data//BirdDiv_BBS_OH.csv", header = TRUE)

BBSGeo <- SpatialPointsDataFrame(cbind(BBS_div$Longi, BBS_div$Lati), data = BBS_div, proj4string = CRS(proj4string(OHco)))

o <- over(BBSGeo, OHco, returnList = FALSE)
BBSGeo@data = cbind(BBSGeo@data,o$GEOID,o$NAME)

write.csv(BBSGeo@data, file = "BBSdata.by.county.csv", row.names = FALSE)

plot(OHco)
points(BBSGeo)
```














Soils for each county: 
Giving up on this. Map of soil taxonomy in US shows that most of OH is same class. The CRA (Common Resource Area) that I was going to use is based on things besides soils, like human needs and aspirations or shit like that. It's a fuzzy definition and no GIS tool in R really overlays polygons on polygons to summarize attributes from one to another.

```{r}


library(rgdal)
library(raster)
library(plotKML)
library(rgeos)
library(ggmap)
setwd("C:/Users/Tyson/REPO/NCEAS-RENCI_2014/")

quickOHmap <- qmap("Lancaster, OH", zoom = 7, legend = "bottomleft")


co.shp <- "county_OH"
OHco <- readOGR(dsn = getwd(), layer = co.shp)
OHco_p <- spTransform(OHco, CRS(proj4string(CRA)))

test <- aggregate(OHco_p, CRA, max)

```



NLCD Change products
```{r, echo=FALSE}
setwd("C:/Users/Tyson/Desktop/OSS_GIS")
library(rgdal)
library(raster)
library(plotKML)
library(parallel)
library(plyr)
library(dplyr)

# r1 <- raster("area_11_changeproduct/area11_changeproduct5k_111907.img")
# r2 <- raster("area_08_changeproduct/area08_changeproduct5k_111907.img")

#too slow: did this in QGIS
#chg90s <- mosaic(r1,r2,fun=mean, filename="lc_change_90s")

chg90s <- raster("OH_change.tif")

co.shp <- "county_OH"
OHco <- readOGR(dsn = getwd(), layer = co.shp)
OHco_p <- spTransform(OHco, CRS(proj4string(chg90s)))

system.time({

    ### Make function and try it out before parallelizing
    ### ########################################################
    RasterToCounty <- function(GEOID){
      co_sub <- OHco_p[OHco_p$GEOID == GEOID, ]
      co_lc <- extract(chg90s, co_sub)
      counts <- lapply(co_lc, table)
      pct <- lapply(counts, FUN=function(x){x / sum(x)})
      return(list(GEOID, pct))
    }

#     test <- lapply(unique(OHco_p$GEOID)[1:2], RasterToCounty)
    
    ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(3)

    clusterExport(cl, c("OHco_p", "RasterToCounty", "chg90s"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    Results.par <- parLapply(cl, unique(OHco_p$GEOID), RasterToCounty)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})


save(Results.par, file = "lc_OHchg90s.RData") 

load("lc_OHchg90s.RData")
results <- Results.par

###WHAT IS THE BLANK VALUE NAME? Just the index number, removed below

lc_long <- data.frame()
for (i in 1:length(results)){
  GEOID <- unique(OHco_p$GEOID)[i]
  Prop.area <- unlist(results[[i]])[-1]
  Value <- c(names(unlist(results[[i]])))[-1]
  temp <- data.frame(GEOID,Prop.area,Value)
  lc_long <- rbind(lc_long, temp)
}

co_desc <- OHco_p@data
co_desc <- co_desc[, c("GEOID", "NAME", "ALAND", "AWATER", "INTPTLAT", "INTPTLON")]

county_lc <- merge(lc_long, co_desc)

a <- county_lc %>% group_by(GEOID, Value) %>% mutate(prop.land.area = Prop.area * (ALAND + AWATER) / ALAND) %>% data.frame()

#Need to remove water and No data
plot(a$Prop.area, a$prop.land.area)

#translation table to reclass land cover values
# tt <- cbind(c("0", landclass$Value), c("missing", "water", "ice", "urb", "urb", "urb", "urb", "barren", "forest", "forest", "forest", rep("grass_shrub", 6), "agr", "agr", "wetlands", "wetlands"))
# 
# a$reclass = as.factor(tt[ match(a$Value, tt[, 1]), 2] )

a$Value <- as.character(a$Value)
# b <- ddply(a, .(GEOID, Value), mutate,
#            Class.prop = sum(prop.land.area))
# 
# county_lc <- b[b$reclass %in% c("agr", "urb", "forest", "grass_shrub", "wetlands"), c("GEOID", "NAME", "ALAND", "INTPTLAT", "INTPTLON", "reclass", "Class.prop")]

# county_lc <- county_lc[-(which(duplicated(county_lc))), ]

#FIGURE OUT HOW TO USE CHANGE MATRIX LATER
write.csv(a, file = "OH_LCchg90s.csv", row.names = FALSE)


library(ggplot2)






```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.








Need to redo the 2006 by county land classes, because I lumped crops and hay together. Should keep separate for pesticides.

```{r}
library(rgdal)
library(raster)
library(plotKML)
library(plyr)
library(dplyr)

setwd("C:/Users/Tyson/Dropbox/Neonicotenoids/Final GIS layers")

lc <- raster("OH_LC2006.tif")
proj4string(lc) <- CRS("+init=epsg:2163")

co.shp <- "oh_counties_plus"
OHco <- readOGR(dsn = getwd(), layer = co.shp)
OHco_p <- reproject(OHco, proj4string(lc))

OHco_sp <- spTransform(OHco, CRS(proj4string(lc)))

library(parallel)
system.time({

    ### Make function and try it out before parallelizing
    ### ########################################################
    RasterToCounty <- function(GEOID){
      co_sub <- OHco_p[which(OHco_p$GEOID == 18001), ]
      co_lc <- extract(lc, co_sub)
      counts <- lapply(co_lc, table)
#       pct <- lapply(counts, FUN=function(x){x / sum(x)})
      return(list(GEOID, counts))
    }
# 
     test <- lapply(unique(OHco_p$GEOID)[1:2], RasterToCounty)
    
    ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(3)

    clusterExport(cl, c("OHco_p", "RasterToCounty", "lc"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    Results.par <- parLapply(cl, unique(OHco_p$GEOID), RasterToCounty)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})


save(Results.par, file = "lc_OH2006.RData") 

load(file = "lc_OH2001.RData")

landclass <- data.frame(Value = c(11, 12, 21, 22, 23, 24, 31, 41, 42, 43, 51, 52, 71, 72, 73, 74, 81, 82, 90, 95), Class = c("Open water", "Ice.snow", "Developed.open", "Developed.low", "Developed.med", "Developed.high", "Barren", "Forest.dec", "Forest.evg", "Forest.mix", "Scrub.dwarf", "Shrub", "Herb.grass", "Herb.sedge", "Herb.lichens", "Herb.moss", "Cult.hay", "Cult.crops", "Wetlands.wood", "Wetlands.herb"))

results <- Results.par

lc_long <- data.frame()
for (i in 1:length(results)){
  GEOID <- unique(OHco_p$GEOID)[i]
  Prop.area <- unlist(results[[i]])
  Value <- c(names(unlist(results[[i]])))
  temp <- data.frame(GEOID,Prop.area,Value)
  lc_long <- rbind(lc_long, temp)
}

co_desc <- OHco_p@data
co_desc <- co_desc[, c("GEOID", "NAME", "ALAND", "AWATER", "INTPTLAT", "INTPTLON")]

county_lc <- merge(lc_long, co_desc)

a <- county_lc %>% group_by(GEOID, Value) %>% mutate(prop.land.area = Prop.area * (ALAND + AWATER) / ALAND) %>% data.frame()

#Need to remove water and No data
plot(a$Prop.area, a$prop.land.area)

#translation table to reclass land cover values
tt <- cbind(c("0", landclass$Value), c("missing", "water", "ice", "urb", "urb", "urb", "urb", "barren", "forest", "forest", "forest", rep("grass_shrub", 6), "agr", "agr", "wetlands", "wetlands"))

a$reclass = as.factor(tt[ match(a$Value, tt[, 1]), 2] )

b <- ddply(a, .(GEOID, reclass), mutate,
           Class.prop = sum(prop.land.area))

county_lc <- b[b$reclass %in% c("agr", "urb", "forest", "grass_shrub", "wetlands"), c("GEOID", "NAME", "ALAND", "INTPTLAT", "INTPTLON", "reclass", "Class.prop")]

county_lc <- county_lc[-(which(duplicated(county_lc))), ]
write.csv(county_lc, file = "county_lc2001.csv", row.names = FALSE)
```

