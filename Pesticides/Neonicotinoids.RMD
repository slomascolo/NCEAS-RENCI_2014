---
title: "Neonicotinoids in OH"
author: "Tyson Wepprich"
date: "Thursday, October 02, 2014"
output: pdf_document
---
Rapid fire science team tackles neonicotinoid effects on birds and butterflies.

This chunk just brings together the pesticides estimates from USGS. Now updated with preliminary data for 2010-11.
Also split with neonicotinoids (+fipronil) only.

```{r}
setwd("C:/Users/Tyson/Desktop/Pesticides")
filenames <- list.files()
EPA.high <- do.call("rbind", lapply(filenames[grep("EPest.high", filenames)], read.table, header = TRUE, sep = "\t"))
EPA.low <- do.call("rbind", lapply(filenames[grep("EPest.low", filenames)], read.table, header = TRUE, sep = "\t"))

#updated 2010-11 preliminary data
setwd("C:/Users/Tyson/Desktop/Pesticides/prelim2010")
filenames <- list.files()
EPA.high.pre <- do.call("rbind", lapply(filenames[grep("EPest.high", filenames)], read.table, header = TRUE, sep = "\t"))
EPA.low.pre <- do.call("rbind", lapply(filenames[grep("EPest.low", filenames)], read.table, header = TRUE, sep = "\t"))

setwd("C:/Users/Tyson/Desktop/Pesticides")


EPA.high <- rbind(EPA.high, EPA.high.pre)
EPA.low <- rbind(EPA.low, EPA.low.pre)

#subset by OHIO
pest.states.low <- EPA.low[which(EPA.low$STATE_FIPS_CODE == 39), ]
pest.states.high <- EPA.high[which(EPA.high$STATE_FIPS_CODE == 39), ]

fips <- read.csv("fips_codes.txt", header = TRUE)
names(fips) <- c("State", "STATE_FIPS_CODE", "COUNTY_FIPS_CODE", "County.Name", "ANSI.class")
fips <- fips[which(fips$STATE_FIPS_CODE == 39), ]
fips$GEOID <- paste(fips$STATE_FIPS_CODE, formatC(fips$COUNTY_FIPS_CODE, width = 3, format = "d", flag = "0"), sep = "")

county.data.low <- merge(pest.states.low, fips)
county.data.high <- merge(pest.states.high, fips)
names(county.data.high)[5] <- "KG_EPhigh"
names(county.data.low)[5] <- "KG_EPlow"
county.data <- merge(county.data.high, county.data.low, all.x = TRUE)

#Bring in county data from 2010 US Census (from factfinder online database)
census <- read.table("Gaz_counties_national.txt", header = TRUE, sep = "\t")
OH.census <- census[census$USPS == "OH", ]

OH.co.pesticides <- merge(county.data, OH.census)

write.csv(OH.co.pesticides, file = "OHpesticides.csv", row.names = FALSE)

OH.co.pesticides <- OH.pest

OH.co.pesticides$density_low <- OH.co.pesticides$KG_EPlow / OH.co.pesticides$ALAND_SQMI
OH.co.pesticides$density_high <- OH.co.pesticides$KG_EPhigh / OH.co.pesticides$ALAND_SQMI

#just neonicotinoids (and Fipronil because it's similar)
OH.co.pesticides$COMPOUND <- as.character(OH.co.pesticides$COMPOUND)
nicos <- c("ACETAMIPRID", "CLOTHIANIDIN", "FIPRONIL", "IMIDACLOPRID", "THIACLOPRID", "THIAMETHOXAM")
OH.neonico <- OH.co.pesticides[which(OH.co.pesticides$COMPOUND %in% nicos), ]
OH.neonico$density_low <- OH.neonico$KG_EPlow / OH.neonico$ALAND_SQMI
OH.neonico$density_high <- OH.neonico$KG_EPhigh / OH.neonico$ALAND_SQMI
write.csv(OH.neonico, file = "OH.neonicotinoids.csv", row.names = FALSE)
```

This chunk plots pesticide use over time by county in Ohio.

```{r}
library(ggplot2)
library(rgdal)
library(RColorBrewer)
library(sp)
library(classInt)
setwd("C:/Users/Tyson/REPO/NCEAS-RENCI_2014/Pesticides")

OH.pest <- read.csv("OHpesticides.csv", header = TRUE)
pest <- OH.pest[which(OH.pest$STATE_FIPS_CODE == 39 & OH.pest$COMPOUND == "IMIDACLOPRID"), ]

OH.neonico <- read.csv("OH.neonicotinoids.csv", header = TRUE)
base <- ggplot(data = OH.neonico, aes(x = YEAR, y = density_high, group = County.Name)) + geom_point()
base + facet_grid( ~ COMPOUND) + theme_bw(base_size = 24)

setwd("C:/Users/Tyson/Dropbox/Neonicotenoids/Final GIS layers")
co.shp <- "oh_counties_plus"
OHco <- readOGR(dsn = getwd(), layer = co.shp)
OHco <- OHco[OHco$STATEFP == 39,]

#make color scale across all years to see change in intensity over time
compounds <- unique(OH.neonico$COMPOUND)
pest <- OH.neonico[OH.neonico$COMPOUND == compounds[1], ]


#select color palette and the number colors to represent on the map
colors <- brewer.pal(9, "YlOrRd")
#set breaks for the 10 colors
brks<-classIntervals(pest$density_high, n=9, style="quantile")
brks<- brks$brks

par(mfrow=c(1, max(pest$YEAR) - min(pest$YEAR) + 1), mar=c(1,1,1,1)+0.1, oma=c(1,1,1,1)+0.1)
par(mfrow=c(2, 9), mar=c(1,1,1,1)+0.1, oma=c(1,1,1,1)+0.1)

for (i in min(pest$YEAR):max(pest$YEAR)){
  
  temp <- pest[pest$YEAR == i, ]
  to.map <- merge(OHco, temp, by = "GEOID")

  #plot the map
  plot(to.map, col=colors[findInterval(to.map$density_high, brks,all.inside=TRUE)], axes=F)
  title(main = as.character(i))
}


# to.map <- merge(OHco, pest, by = "GEOID")
# 
# #select color palette and the number colors to represent on the map
# colors <- brewer.pal(9, "YlOrRd")
# 
# #set breaks for the 9 colors
# brks<-classIntervals(to.map$density_high, n=9, style="quantile")
# brks<- brks$brks
# 
# #plot the map
# plot(to.map, col=colors[findInterval(to.map$density_high, brks,all.inside=TRUE)], axes=F)
# 
# #add a title
# title(paste ("SF Bay Area Median Household Income"))
# 
# #add a legend
# legend(x=6298809, y=2350000, legend=leglabs(round(brks)), fill=colors, bty="n",x.intersp = .5, y.intersp = .5)


```

GIS analysis of pesticides and land-use change in different counties, along BBS routes, and around butterfly sites.

Goals: 
Characterize land-use (compare to previous analysis on BBS routes at different scales)
Find change in land use from 1992-2011 (with 2001, 2006)
Pesticide use by year (neonicotenoids and other categories as control?)

Steps:
BBS route shapefile, get buffers at different scales.
Verify that the routes are the same ones for population estimates.
Make sure locations are accurate for butterfly site coordinates.
Butterfly sites, get buffers at different scales.

Land-use
Get 2001, 2006, 2011 estimates from buffers.
Get 1992/2001 change product for buffers and subtract from 2001 for 1992 estimate.
Verify time-series with 2001/06 and 2001/11 change products.
Take care with changing land-use classification schemes. Keep all categories as is until end.
Might need counties bordering OH.

Pesticides
Take county-level estimates and disaggregate as mean kg/acre cropland.
Reaggregate in BBS and butterfly site buffers.
Do neonicotenoids and which other pesticides? Maybe other frequently used ones like glyphosate/atrazine.
Might need counties bordering OH.



```{r OH county+ land cover}
library(rgdal)
library(raster)
library(plotKML)
library(rgeos)
library(parallel)
setwd("C:/Users/Tyson/Desktop")



#import 2006 OH Land Cover raster
test.file <- "C:/Users/Tyson/Desktop/Clipped/Final clipped/lc2006.tif"
r <- raster(test.file)
# hasValues(r)
# inMemory(r)
# plot(r)

proj4string(r) <- CRS("+init=epsg:5070")


#Import shapefile of OH counties and bordering counties in other states.
#Already has 5 digist GEOID, use this to match with pesticides.
co.shp <- "oh_counties_plus"
OHco <- readOGR(dsn = "C:/Users/Tyson/Desktop/Clipped/Final clipped", layer = co.shp)
# proj4string(OHco) <- CRS("+init=epsg:5070")
OHco_p <- reproject(OHco, proj4string(r))

#Import BBS routes shapefile, obtained from DataBasin
#These are the 1998 active routes, need to see how well they match up with routes used for population estimates
bbs.shp <- "bbsrtsl020Copy"
bbs_routes <- readOGR(dsn = "C:/Users/Tyson/Dropbox/Neonicotenoids/Final GIS layers", layer = bbs.shp)
# proj4string(bbs_routes) <- CRS("+init=epsg:5070")
bbs_routes_p <- reproject(bbs_routes, proj4string(r))

#RTENO: The route number consists of the 1- or 2-digit State ID code followed by the 3-digit route ID.
bbs_OH <- bbs_routes_p[which(bbs_routes_p$RTENO >= 66000 & bbs_routes_p$RTENO <=67000), ]

bbs_buff_200 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 200, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_400 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 400, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_1000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 1000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_2000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 2000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_5000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 5000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_10000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 10000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
# writeOGR(bbs_buff_10000, dsn = getwd(), "test10000", driver = "ESRI Shapefile")

require( parallel )
#beginCluster( detectCores()-1 )

#Parallel function

    ### Make function and try it out before parallelizing
    ### ########################################################
    RasterToBuffer <- function(RTENO){
      rt <- buff[which(buff$RTENO == RTENO), ]
      lc <- extract(r, rt)
      counts <- lapply(lc, table)
      return(list(RTENO, counts))
    }

  # test <- lapply(unique(buff$RTENO)[1:2], RasterToBuffer)

system.time({
####
#Extract land cover for all BBS buffers
bbs_buffs <- list(bbs_buff_200, bbs_buff_400, bbs_buff_1000, bbs_buff_2000, bbs_buff_5000, bbs_buff_10000)
results <- list()
for (j in 1:length(bbs_buffs)){
  buff <- bbs_buffs[[j]]
  buff <- spTransform(buff, CRS(proj4string(r)))
  system.time({
     ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(detectCores() - 1)

    clusterExport(cl, c("buff", "RasterToBuffer", "r"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    Results.par <- parLapply(cl, unique(buff$RTENO), RasterToBuffer)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})

results[[j]] <- Results.par
}
})

save(results, file = "BBS_LC_2006.RData") 


##################################################
#2011
##################################################
#import 2001 OH Land Cover raster
test.file <- "C:/Users/Tyson/Desktop/Clipped/Final clipped/lc2001.tif"
r <- raster(test.file)
# hasValues(r)
# inMemory(r)
# plot(r)

proj4string(r) <- CRS("+init=epsg:5070")


#Import shapefile of OH counties and bordering counties in other states.
#Already has 5 digist GEOID, use this to match with pesticides.
co.shp <- "oh_counties_plus"
OHco <- readOGR(dsn = "C:/Users/Tyson/Desktop/Clipped/Final clipped", layer = co.shp)
# proj4string(OHco) <- CRS("+init=epsg:5070")
OHco_p <- reproject(OHco, proj4string(r))

#Import BBS routes shapefile, obtained from DataBasin
#These are the 1998 active routes, need to see how well they match up with routes used for population estimates
bbs.shp <- "bbsrtsl020Copy"
bbs_routes <- readOGR(dsn = "C:/Users/Tyson/Dropbox/Neonicotenoids/Final GIS layers", layer = bbs.shp)
# proj4string(bbs_routes) <- CRS("+init=epsg:5070")
bbs_routes_p <- reproject(bbs_routes, proj4string(r))

#RTENO: The route number consists of the 1- or 2-digit State ID code followed by the 3-digit route ID.
bbs_OH <- bbs_routes_p[which(bbs_routes_p$RTENO >= 66000 & bbs_routes_p$RTENO <=67000), ]

bbs_buff_200 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 200, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_400 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 400, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_1000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 1000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_2000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 2000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_5000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 5000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_10000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 10000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
# writeOGR(bbs_buff_10000, dsn = getwd(), "test10000", driver = "ESRI Shapefile")

require( parallel )
#beginCluster( detectCores()-1 )

#Parallel function

    ### Make function and try it out before parallelizing
    ### ########################################################
    RasterToBuffer <- function(RTENO){
      rt <- buff[which(buff$RTENO == RTENO), ]
      lc <- extract(r, rt)
      counts <- lapply(lc, table)
      return(list(RTENO, counts))
    }

  # test <- lapply(unique(buff$RTENO)[1:2], RasterToBuffer)


####
#Extract land cover for all BBS buffers
bbs_buffs <- list(bbs_buff_200, bbs_buff_400, bbs_buff_1000, bbs_buff_2000, bbs_buff_5000, bbs_buff_10000)
results <- list()
for (j in 1:length(bbs_buffs)){
  buff <- bbs_buffs[[j]]
  buff <- spTransform(buff, CRS(proj4string(r)))
  system.time({
     ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(detectCores() - 1)

    clusterExport(cl, c("buff", "RasterToBuffer", "r"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    Results.par <- parLapply(cl, unique(buff$RTENO), RasterToBuffer)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})

results[[j]] <- Results.par
}


save(results, file = "BBS_LC_2001.RData") 


#################################################################
#2011
##################################################################

#import 2011 OH Land Cover raster
test.file <- "C:/Users/Tyson/Desktop/Clipped/Final clipped/lc2011.tif"
r <- raster(test.file)
# hasValues(r)
# inMemory(r)
# plot(r)

proj4string(r) <- CRS("+init=epsg:5070")


#Import shapefile of OH counties and bordering counties in other states.
#Already has 5 digist GEOID, use this to match with pesticides.
co.shp <- "oh_counties_plus"
OHco <- readOGR(dsn = "C:/Users/Tyson/Desktop/Clipped/Final clipped", layer = co.shp)
# proj4string(OHco) <- CRS("+init=epsg:5070")
OHco_p <- reproject(OHco, proj4string(r))

#Import BBS routes shapefile, obtained from DataBasin
#These are the 1998 active routes, need to see how well they match up with routes used for population estimates
bbs.shp <- "bbsrtsl020Copy"
bbs_routes <- readOGR(dsn = "C:/Users/Tyson/Dropbox/Neonicotenoids/Final GIS layers", layer = bbs.shp)
# proj4string(bbs_routes) <- CRS("+init=epsg:5070")
bbs_routes_p <- reproject(bbs_routes, proj4string(r))

#RTENO: The route number consists of the 1- or 2-digit State ID code followed by the 3-digit route ID.
bbs_OH <- bbs_routes_p[which(bbs_routes_p$RTENO >= 66000 & bbs_routes_p$RTENO <=67000), ]

bbs_buff_200 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 200, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_400 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 400, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_1000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 1000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_2000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 2000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_5000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 5000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
bbs_buff_10000 <- gBuffer(bbs_OH, byid = TRUE, id = NULL, width = 10000, quadsegs = 5, capStyle = "ROUND", joinStyle = "ROUND")
# writeOGR(bbs_buff_10000, dsn = getwd(), "test10000", driver = "ESRI Shapefile")

require( parallel )
#beginCluster( detectCores()-1 )

#Parallel function

    ### Make function and try it out before parallelizing
    ### ########################################################
    RasterToBuffer <- function(RTENO){
      rt <- buff[which(buff$RTENO == RTENO), ]
      lc <- extract(r, rt)
      counts <- lapply(lc, table)
      return(list(RTENO, counts))
    }

  # test <- lapply(unique(buff$RTENO)[1:2], RasterToBuffer)


####
#Extract land cover for all BBS buffers
bbs_buffs <- list(bbs_buff_200, bbs_buff_400, bbs_buff_1000, bbs_buff_2000, bbs_buff_5000, bbs_buff_10000)
results <- list()
for (j in 1:length(bbs_buffs)){
  buff <- bbs_buffs[[j]]
  buff <- spTransform(buff, CRS(proj4string(r)))
  system.time({
     ### set up cluster call
    ### ######################################################
    cl <- makePSOCKcluster(detectCores() - 1)

    clusterExport(cl, c("buff", "RasterToBuffer", "r"))
    junk <- clusterEvalQ(cl, c(library(raster), library(rgdal)))

    ### read into raster format using parallel version of lapply
    ### #################
    Results.par <- parLapply(cl, unique(buff$RTENO), RasterToBuffer)

    ### stop the cluster
    ### #########################################################
    stopCluster(cl)
})

results[[j]] <- Results.par
}


save(results, file = "BBS_LC_2011.RData") 













#bring together counts of Land Cover classes for each buffer
load("BBS_LC_2006.RData")
buffer <- c(200,400,1000,2000,5000,10000)

out <- data.frame()
for (i in 1:6){
  for (j in 1:70){
    temp <- results[[i]][[j]]
    temp.df <- data.frame(lc_class = names(unlist(temp[[2]])), pixels = as.numeric(unlist(temp[[2]])))
    temp.df$BBS_route <- unlist(temp[[1]])
    temp.df$buffer <- buffer[i]
    out <- rbind(out,temp.df)
  }
}





```
















